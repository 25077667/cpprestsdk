// This is the testing driver for checking if the cpprest::web::json::value is supporting entire UTF-16 range.
#include <cpprest/json.h>
#include <exception>
#include <iomanip>
#include <iostream>
#include <stdint.h>
#include <vector>

namespace detail
{
// Copy an int(32_bit) binary data to a utility::string_t
utility::string_t int_to_string_t(int32_t i)
{
    utility::string_t result;
    // Push third byte
    result.push_back((i >> 8) & 0xFF);
    // Push fourth byte
    result.push_back(i & 0xFF);
    // Push first byte
    result.push_back((i >> 24) & 0xFF);
    // Push second byte
    result.push_back((i >> 16) & 0xFF);
    return result;
}

utility::string_t utf_generator(uint32_t i) noexcept
{
    if (i < 0x10000) return int_to_string_t(i);

    auto codepoint = i - 0x10000ul;
    auto high = 0xD800 | (codepoint >> 10);
    auto low = 0xDC00 | (codepoint & 0x3FF);
    return int_to_string_t((high << 16) | low);
}

std::string to_hex(uint32_t i)
{
    std::stringstream stream;
    stream << std::setfill('0') << std::setw(sizeof(uint32_t)) << std::hex << i;
    return stream.str();
}

utility::string_t convert_utf16_to_literal(const utility::string_t& str)
{
    // Convert utf16 to "\uXXXX" or "\uXXXX\uXXXX" format
    utility::string_t result;
    for (const int32_t& c : str)
    {
        if (c < 0x10000)
            result += U("\\u") + utility::conversions::to_string_t(to_hex(c));
        else
        {
            auto codepoint = c - 0x10000ul;
            auto high = 0xD800 | (codepoint >> 10);
            auto low = 0xDC00 | (codepoint & 0x3FF);
            result += U("\\u") + utility::conversions::to_string_t(to_hex(high));
            result += U("\\u") + utility::conversions::to_string_t(to_hex(low));
        }
    }
    return result;
}

// Define a range of UTF-16 upper bound
// UTF-16 upper bound is 0x10FFFF, that is only [0, 0x10FFFF] is valid.
constexpr uint32_t utf16_upper_bound = 0x10FFFF;

bool do_try_json(const utility::string_t& key, const web::json::value& value, uint32_t i)
{
    // Throw an exception if any error occurs
    web::json::value json_object = web::json::value::object();
    json_object[key] = value;
    const auto& serialized = json_object.serialize();
    const auto& converted_str = serialized;

    // std::wclog << L"Serialized string: " << serialized << std::endl;
    // std::wclog << L"Converted string: " << converted_str << std::endl;

    if (serialized.empty())
        throw std::runtime_error("Serialized string is empty");
    else if (serialized.find(U("DUMMY")) == utility::string_t::npos)
        throw std::runtime_error("Serialized string does not contain DUMMY");
    else if (serialized.find(converted_str.c_str()) == utility::string_t::npos)
        throw std::runtime_error(std::string("Serialized string does not contain key ") + std::to_string(i));

    const auto& deserialized = web::json::value::parse(json_object.serialize());
    if (deserialized.is_null())
        throw std::runtime_error("Deserialized value is null");
    else if (deserialized.at(key).is_null())
        throw std::runtime_error("Deserialized value does not contain key");
    else if (deserialized.at(key) != value)
        throw std::runtime_error("Deserialized value does not contain DUMMY");

    return true;
}

// Testing for cpprest::web::json::value is a json object and the key is supporting entire UTF-16 range.
// And the value is "DUMMY".
bool check_json_object() noexcept
{
    //  A callback function on error
    auto on_error = [](const std::exception& e)
    {
        std::cout << e.what() << std::endl;
        return false;
    };

    // a loop constructing a temporary json object
    for (uint32_t i = 0; i <= utf16_upper_bound; ++i)
    {
        const auto& [key, value] = std::make_pair(utf_generator(i), web::json::value::string(U("DUMMY")));
        std::clog << "Testing " << i << " for key\n";
        try
        {
            do_try_json(key, value, i);
        }
        catch (const std::exception& e)
        {
            return on_error(e);
        }
    }

    // Testing another json object, key is normal string, value is generated by utf_generator
    for (uint32_t i = 0; i <= utf16_upper_bound; ++i)
    {
        const auto& [key, value] =
            std::make_pair(utility::string_t(U("DUMMY")), web::json::value::string(utf_generator(i)));
        std::clog << "Testing " << i << " for value\n";
        try
        {
            do_try_json(key, value, i);
        }
        catch (const std::exception& e)
        {
            return on_error(e);
        }
    }

    return true;
}
}; // namespace detail

int main()
{
    std::cout << "Testing cpprest::web::json::value is supporting entire UTF-16 range..." << std::endl;
    if (detail::check_json_object())
        std::cout << "Test passed" << std::endl;
    else
        std::cout << "Test failed" << std::endl;
    return 0;
}